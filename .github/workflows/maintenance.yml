# Automated Maintenance Workflow
# =============================================================================
# This workflow handles routine maintenance tasks
# Note: This file is created as a template. User needs to review and implement.

name: Automated Maintenance

on:
  schedule:
    # Daily maintenance at 2 AM UTC
    - cron: '0 2 * * *'
    # Weekly comprehensive maintenance on Sundays at 3 AM UTC
    - cron: '0 3 * * 0'
  workflow_dispatch:
    inputs:
      maintenance_type:
        description: 'Type of maintenance to run'
        required: true
        default: 'daily'
        type: choice
        options:
        - daily
        - weekly
        - full

jobs:
  # ===========================================================================
  # Daily Maintenance Tasks
  # ===========================================================================
  
  daily-maintenance:
    name: Daily Maintenance
    runs-on: ubuntu-latest
    if: github.event.schedule == '0 2 * * *' || github.event.inputs.maintenance_type == 'daily' || github.event.inputs.maintenance_type == 'full'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Clean up old workflow runs
      uses: actions/github-script@v6
      with:
        script: |
          const { data: workflows } = await github.rest.actions.listRepoWorkflows({
            owner: context.repo.owner,
            repo: context.repo.repo,
          });

          for (const workflow of workflows.workflows) {
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflow.id,
              status: 'completed',
              per_page: 100,
            });

            // Keep only the last 50 runs per workflow
            const runsToDelete = runs.workflow_runs.slice(50);
            
            for (const run of runsToDelete) {
              if (new Date() - new Date(run.created_at) > 30 * 24 * 60 * 60 * 1000) { // 30 days old
                try {
                  await github.rest.actions.deleteWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.id,
                  });
                  console.log(`Deleted workflow run ${run.id}`);
                } catch (error) {
                  console.log(`Failed to delete run ${run.id}: ${error.message}`);
                }
              }
            }
          }

    - name: Update issue labels
      uses: actions/github-script@v6
      with:
        script: |
          // Close stale issues
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'stale',
            sort: 'updated',
            direction: 'asc',
            per_page: 100,
          });

          for (const issue of issues) {
            const lastUpdate = new Date(issue.updated_at);
            const daysSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60 * 24);
            
            if (daysSinceUpdate > 30) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'not_planned'
              });
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: 'This issue was automatically closed due to inactivity. If this issue is still relevant, please reopen it.'
              });
            }
          }

    - name: Generate repository metrics
      run: |
        echo "Generating daily repository metrics..."
        
        # Create metrics file
        cat > .github/metrics.json << EOF
        {
          "generated_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
          "repository": "${{ github.repository }}",
          "metrics": {
            "maintenance": {
              "last_run": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "type": "daily"
            }
          }
        }
        EOF

    - name: Update maintenance log
      run: |
        echo "$(date -u): Daily maintenance completed" >> .github/maintenance.log
        tail -100 .github/maintenance.log > .github/maintenance.log.tmp
        mv .github/maintenance.log.tmp .github/maintenance.log

  # ===========================================================================
  # Weekly Maintenance Tasks
  # ===========================================================================
  
  weekly-maintenance:
    name: Weekly Maintenance
    runs-on: ubuntu-latest
    if: github.event.schedule == '0 3 * * 0' || github.event.inputs.maintenance_type == 'weekly' || github.event.inputs.maintenance_type == 'full'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install maintenance dependencies
      run: |
        pip install pip-audit safety bandit semgrep

    - name: Security audit
      run: |
        echo "Running weekly security audit..."
        
        # Create security report
        mkdir -p reports
        
        # Run pip-audit
        pip-audit --format=json --output=reports/pip-audit.json || true
        
        # Run safety check
        safety check --json --output reports/safety.json || true
        
        # Run bandit scan
        bandit -r src/ -f json -o reports/bandit.json || true

    - name: Generate security summary
      run: |
        python << 'EOF'
        import json
        import os
        from datetime import datetime

        def load_json_safe(file_path):
            try:
                with open(file_path, 'r') as f:
                    return json.load(f)
            except:
                return {}

        # Load security reports
        pip_audit = load_json_safe('reports/pip-audit.json')
        safety = load_json_safe('reports/safety.json')
        bandit = load_json_safe('reports/bandit.json')

        # Generate summary
        summary = {
            "generated_at": datetime.utcnow().isoformat() + "Z",
            "security_scan": {
                "pip_audit_vulnerabilities": len(pip_audit.get('vulnerabilities', [])),
                "safety_vulnerabilities": len(safety) if isinstance(safety, list) else 0,
                "bandit_issues": len(bandit.get('results', [])),
                "overall_status": "clean"
            }
        }

        # Determine overall status
        total_issues = (
            summary["security_scan"]["pip_audit_vulnerabilities"] +
            summary["security_scan"]["safety_vulnerabilities"] +
            summary["security_scan"]["bandit_issues"]
        )
        
        if total_issues > 0:
            summary["security_scan"]["overall_status"] = "issues_found"

        # Save summary
        with open('reports/security-summary.json', 'w') as f:
            json.dump(summary, f, indent=2)

        print(f"Security scan completed. Total issues: {total_issues}")
        EOF

    - name: Check for dependency updates
      run: |
        echo "Checking for dependency updates..."
        
        # Check Python dependencies
        pip list --outdated --format=json > reports/outdated-packages.json
        
        # Count outdated packages
        python << 'EOF'
        import json
        
        with open('reports/outdated-packages.json', 'r') as f:
            outdated = json.load(f)
        
        print(f"Found {len(outdated)} outdated packages")
        
        # Create summary
        if len(outdated) > 10:
            print("⚠️ Many packages are outdated. Consider running dependency updates.")
        elif len(outdated) > 0:
            print(f"📦 {len(outdated)} packages can be updated.")
        else:
            print("✅ All packages are up to date.")
        EOF

    - name: Generate code quality metrics
      run: |
        echo "Generating code quality metrics..."
        
        # Install quality tools
        pip install radon flake8 pylint
        
        # Run radon complexity analysis
        radon cc src/ --json > reports/complexity.json || true
        
        # Run maintainability index
        radon mi src/ --json > reports/maintainability.json || true

    - name: Create weekly report
      run: |
        python << 'EOF'
        import json
        import os
        from datetime import datetime

        def load_json_safe(file_path):
            try:
                with open(file_path, 'r') as f:
                    return json.load(f)
            except:
                return {}

        # Load all reports
        security = load_json_safe('reports/security-summary.json')
        outdated = load_json_safe('reports/outdated-packages.json')
        complexity = load_json_safe('reports/complexity.json')

        # Generate comprehensive report
        report = {
            "generated_at": datetime.utcnow().isoformat() + "Z",
            "report_type": "weekly_maintenance",
            "repository": os.environ.get('GITHUB_REPOSITORY', 'unknown'),
            "summary": {
                "security_status": security.get('security_scan', {}).get('overall_status', 'unknown'),
                "total_security_issues": (
                    security.get('security_scan', {}).get('pip_audit_vulnerabilities', 0) +
                    security.get('security_scan', {}).get('safety_vulnerabilities', 0) +
                    security.get('security_scan', {}).get('bandit_issues', 0)
                ),
                "outdated_packages": len(outdated) if isinstance(outdated, list) else 0,
                "code_quality": "analyzed"
            },
            "recommendations": []
        }

        # Add recommendations
        if report["summary"]["total_security_issues"] > 0:
            report["recommendations"].append("🔒 Address security vulnerabilities")
        
        if report["summary"]["outdated_packages"] > 10:
            report["recommendations"].append("📦 Update outdated dependencies")
        
        if not report["recommendations"]:
            report["recommendations"].append("✅ No immediate action required")

        # Save report
        with open('reports/weekly-report.json', 'w') as f:
            json.dump(report, f, indent=2)

        # Print summary
        print("=" * 50)
        print("WEEKLY MAINTENANCE REPORT")
        print("=" * 50)
        print(f"Security Status: {report['summary']['security_status']}")
        print(f"Security Issues: {report['summary']['total_security_issues']}")
        print(f"Outdated Packages: {report['summary']['outdated_packages']}")
        print("\nRecommendations:")
        for rec in report["recommendations"]:
            print(f"- {rec}")
        print("=" * 50)
        EOF

    - name: Upload maintenance reports
      uses: actions/upload-artifact@v3
      with:
        name: maintenance-reports
        path: reports/
        retention-days: 30

    - name: Create issue for high-priority findings
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          
          try {
            const reportData = fs.readFileSync('reports/weekly-report.json', 'utf8');
            const report = JSON.parse(reportData);
            
            const securityIssues = report.summary.total_security_issues;
            const outdatedPackages = report.summary.outdated_packages;
            
            // Create issue if there are significant findings
            if (securityIssues > 0 || outdatedPackages > 20) {
              const title = `🔧 Weekly Maintenance Report - Action Required`;
              const body = `
              ## Weekly Maintenance Report
              
              **Generated:** ${report.generated_at}
              
              ### Summary
              - **Security Issues:** ${securityIssues}
              - **Outdated Packages:** ${outdatedPackages}
              - **Status:** ${report.summary.security_status}
              
              ### Recommendations
              ${report.recommendations.map(rec => `- ${rec}`).join('\n')}
              
              ### Action Items
              ${securityIssues > 0 ? '- [ ] Review and address security vulnerabilities' : ''}
              ${outdatedPackages > 20 ? '- [ ] Update outdated dependencies' : ''}
              - [ ] Review full maintenance report in workflow artifacts
              
              This issue was automatically created by the maintenance workflow.
              `;
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['maintenance', 'automated', 'priority-medium']
              });
            }
          } catch (error) {
            console.log('Could not create maintenance issue:', error.message);
          }

  # ===========================================================================
  # Repository Health Check
  # ===========================================================================
  
  health-check:
    name: Repository Health Check
    runs-on: ubuntu-latest
    if: github.event.inputs.maintenance_type == 'full' || github.event.schedule == '0 3 * * 0'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check repository health
      uses: actions/github-script@v6
      with:
        script: |
          const { data: repo } = await github.rest.repos.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
          
          const health = {
            has_description: !!repo.description,
            has_homepage: !!repo.homepage,
            has_topics: repo.topics && repo.topics.length > 0,
            has_license: !!repo.license,
            has_readme: false,
            default_branch: repo.default_branch,
            open_issues: repo.open_issues_count,
            size_kb: repo.size
          };
          
          // Check for README
          try {
            await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'README.md'
            });
            health.has_readme = true;
          } catch (error) {
            health.has_readme = false;
          }
          
          // Calculate health score
          const checks = [
            health.has_description,
            health.has_homepage,
            health.has_topics,
            health.has_license,
            health.has_readme
          ];
          
          const score = (checks.filter(Boolean).length / checks.length) * 100;
          health.score = Math.round(score);
          
          console.log('Repository Health Score:', score + '%');
          console.log('Health Details:', JSON.stringify(health, null, 2));
          
          // Save health data
          const fs = require('fs');
          fs.writeFileSync('health-report.json', JSON.stringify(health, null, 2));

    - name: Generate repository statistics
      run: |
        echo "Generating repository statistics..."
        
        # Git statistics
        git log --oneline --since="1 month ago" | wc -l > commits_last_month.txt
        git log --oneline --since="1 week ago" | wc -l > commits_last_week.txt
        
        # File statistics
        find src/ -name "*.py" | wc -l > python_files.txt
        find tests/ -name "*.py" | wc -l > test_files.txt 2>/dev/null || echo "0" > test_files.txt
        find docs/ -name "*.md" | wc -l > doc_files.txt 2>/dev/null || echo "0" > doc_files.txt
        
        # Create statistics summary
        python << 'EOF'
        import json
        from datetime import datetime

        def read_count(filename):
            try:
                with open(filename, 'r') as f:
                    return int(f.read().strip())
            except:
                return 0

        stats = {
            "generated_at": datetime.utcnow().isoformat() + "Z",
            "git": {
                "commits_last_month": read_count('commits_last_month.txt'),
                "commits_last_week": read_count('commits_last_week.txt')
            },
            "files": {
                "python_files": read_count('python_files.txt'),
                "test_files": read_count('test_files.txt'),
                "doc_files": read_count('doc_files.txt')
            }
        }

        with open('repository-stats.json', 'w') as f:
            json.dump(stats, f, indent=2)

        print("Repository Statistics:")
        print(json.dumps(stats, indent=2))
        EOF

  # ===========================================================================
  # Cleanup Tasks
  # ===========================================================================
  
  cleanup:
    name: Cleanup Tasks
    runs-on: ubuntu-latest
    if: github.event.inputs.maintenance_type == 'full' || github.event.schedule == '0 3 * * 0'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Clean up old artifacts
      uses: actions/github-script@v6
      with:
        script: |
          const { data: artifacts } = await github.rest.actions.listArtifactsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100,
          });

          const cutoffDate = new Date();
          cutoffDate.setDate(cutoffDate.getDate() - 30); // 30 days ago

          for (const artifact of artifacts.artifacts) {
            const createdAt = new Date(artifact.created_at);
            if (createdAt < cutoffDate) {
              try {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                });
                console.log(`Deleted old artifact: ${artifact.name}`);
              } catch (error) {
                console.log(`Failed to delete artifact ${artifact.id}: ${error.message}`);
              }
            }
          }

    - name: Update maintenance badge
      run: |
        echo "Updating maintenance badge..."
        # This would update a maintenance status badge
        # Implementation depends on your badge system
        echo "Last maintained: $(date -u +"%Y-%m-%d")" > .github/last-maintenance.txt

  # ===========================================================================
  # Notification
  # ===========================================================================
  
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [daily-maintenance, weekly-maintenance, health-check, cleanup]
    if: always()

    steps:
    - name: Send maintenance summary
      uses: actions/github-script@v6
      with:
        script: |
          const maintenanceType = "${{ github.event.inputs.maintenance_type || 'scheduled' }}";
          const success = "${{ job.status }}" === "success";
          
          console.log(`Maintenance completed: ${maintenanceType} (${success ? 'SUCCESS' : 'FAILED'})`);
          
          // Here you could send notifications to Slack, Discord, email, etc.
          // Example for creating a summary issue comment:
          if (!success) {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `❌ Maintenance Failed - ${maintenanceType}`,
              body: `The ${maintenanceType} maintenance workflow has failed. Please check the workflow logs.`,
              labels: ['maintenance', 'failure', 'high-priority']
            });
          }