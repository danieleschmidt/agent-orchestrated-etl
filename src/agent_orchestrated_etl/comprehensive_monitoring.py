"""Comprehensive monitoring system with real-time metrics and alerting."""

import asyncio
import json
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Union

from .logging_config import get_logger


class MetricType(Enum):
    """Types of metrics that can be collected."""
    COUNTER = "counter"
    GAUGE = "gauge"
    HISTOGRAM = "histogram"
    TIMER = "timer"


class AlertSeverity(Enum):
    """Severity levels for alerts."""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


@dataclass
class Metric:
    """A metric data point."""
    name: str
    value: Union[int, float]
    metric_type: MetricType
    timestamp: float = field(default_factory=time.time)
    labels: Dict[str, str] = field(default_factory=dict)
    unit: Optional[str] = None


@dataclass
class Alert:
    """An alert generated by the monitoring system."""
    name: str
    severity: AlertSeverity
    message: str
    timestamp: float = field(default_factory=time.time)
    component: Optional[str] = None
    labels: Dict[str, str] = field(default_factory=dict)
    resolved: bool = False


@dataclass
class HealthStatus:
    """Health status of a component."""
    component: str
    healthy: bool
    last_check: float = field(default_factory=time.time)
    error_message: Optional[str] = None
    metrics: Dict[str, float] = field(default_factory=dict)


class MetricsCollector:
    """Collects and stores metrics from various components."""

    def __init__(self, retention_period: int = 3600):
        self.logger = get_logger("agent_etl.monitoring.collector")
        self.metrics: List[Metric] = []
        self.retention_period = retention_period
        self.aggregated_metrics: Dict[str, Dict[str, Any]] = {}

    def record_metric(
        self,
        name: str,
        value: Union[int, float],
        metric_type: MetricType = MetricType.GAUGE,
        labels: Optional[Dict[str, str]] = None,
        unit: Optional[str] = None
    ) -> None:
        """Record a metric."""
        metric = Metric(
            name=name,
            value=value,
            metric_type=metric_type,
            labels=labels or {},
            unit=unit
        )

        self.metrics.append(metric)
        self._update_aggregated_metrics(metric)
        self._cleanup_old_metrics()

    def increment_counter(self, name: str, labels: Optional[Dict[str, str]] = None) -> None:
        """Increment a counter metric."""
        current_value = self._get_current_counter_value(name, labels or {})
        self.record_metric(name, current_value + 1, MetricType.COUNTER, labels)

    def set_gauge(self, name: str, value: Union[int, float], labels: Optional[Dict[str, str]] = None) -> None:
        """Set a gauge metric."""
        self.record_metric(name, value, MetricType.GAUGE, labels)

    def record_timer(self, name: str, duration: float, labels: Optional[Dict[str, str]] = None) -> None:
        """Record a timer metric."""
        self.record_metric(name, duration, MetricType.TIMER, labels, "seconds")

    def record_histogram(self, name: str, value: float, labels: Optional[Dict[str, str]] = None) -> None:
        """Record a histogram metric."""
        self.record_metric(name, value, MetricType.HISTOGRAM, labels)

    def get_metrics(self, name: Optional[str] = None, since: Optional[float] = None) -> List[Metric]:
        """Get metrics, optionally filtered by name and time."""
        metrics = self.metrics

        if name:
            metrics = [m for m in metrics if m.name == name]

        if since:
            metrics = [m for m in metrics if m.timestamp >= since]

        return metrics

    def get_aggregated_metrics(self) -> Dict[str, Dict[str, Any]]:
        """Get aggregated metrics summary."""
        return self.aggregated_metrics.copy()

    def _get_current_counter_value(self, name: str, labels: Dict[str, str]) -> int:
        """Get current value of a counter."""
        recent_metrics = [
            m for m in self.metrics
            if m.name == name and m.metric_type == MetricType.COUNTER and m.labels == labels
        ]

        if recent_metrics:
            return int(recent_metrics[-1].value)
        return 0

    def _update_aggregated_metrics(self, metric: Metric) -> None:
        """Update aggregated metrics."""
        key = f"{metric.name}_{json.dumps(metric.labels, sort_keys=True)}"

        if key not in self.aggregated_metrics:
            self.aggregated_metrics[key] = {
                "name": metric.name,
                "labels": metric.labels,
                "count": 0,
                "sum": 0.0,
                "min": float('inf'),
                "max": float('-inf'),
                "last_value": 0.0,
                "last_updated": 0.0
            }

        agg = self.aggregated_metrics[key]
        agg["count"] += 1
        agg["sum"] += metric.value
        agg["min"] = min(agg["min"], metric.value)
        agg["max"] = max(agg["max"], metric.value)
        agg["last_value"] = metric.value
        agg["last_updated"] = metric.timestamp
        agg["average"] = agg["sum"] / agg["count"]

    def _cleanup_old_metrics(self) -> None:
        """Remove metrics older than retention period."""
        cutoff_time = time.time() - self.retention_period
        self.metrics = [m for m in self.metrics if m.timestamp >= cutoff_time]


class AlertManager:
    """Manages alerts and notifications."""

    def __init__(self):
        self.logger = get_logger("agent_etl.monitoring.alerts")
        self.alerts: List[Alert] = []
        self.alert_rules: List[Dict[str, Any]] = []
        self.notification_channels: List[Callable] = []

    def add_alert_rule(
        self,
        name: str,
        condition: Callable[[Dict[str, Any]], bool],
        severity: AlertSeverity = AlertSeverity.WARNING,
        message_template: str = "Alert triggered: {name}"
    ) -> None:
        """Add an alert rule."""
        rule = {
            "name": name,
            "condition": condition,
            "severity": severity,
            "message_template": message_template,
            "last_triggered": 0.0
        }
        self.alert_rules.append(rule)
        self.logger.info(f"Added alert rule: {name}")

    def add_notification_channel(self, channel: Callable[[Alert], None]) -> None:
        """Add a notification channel."""
        self.notification_channels.append(channel)

    def check_alerts(self, metrics: Dict[str, Any]) -> List[Alert]:
        """Check all alert rules against current metrics."""
        new_alerts = []

        for rule in self.alert_rules:
            try:
                if rule["condition"](metrics):
                    # Avoid spam - only trigger if not recently triggered
                    if time.time() - rule["last_triggered"] > 300:  # 5 minutes
                        alert = Alert(
                            name=rule["name"],
                            severity=rule["severity"],
                            message=rule["message_template"].format(name=rule["name"])
                        )

                        new_alerts.append(alert)
                        self.alerts.append(alert)
                        rule["last_triggered"] = time.time()

                        # Send notifications
                        for channel in self.notification_channels:
                            try:
                                channel(alert)
                            except Exception as e:
                                self.logger.error(f"Failed to send notification: {e}")

            except Exception as e:
                self.logger.error(f"Error checking alert rule {rule['name']}: {e}")

        return new_alerts

    def resolve_alert(self, alert_name: str) -> bool:
        """Resolve an alert by name."""
        for alert in self.alerts:
            if alert.name == alert_name and not alert.resolved:
                alert.resolved = True
                self.logger.info(f"Resolved alert: {alert_name}")
                return True
        return False

    def get_active_alerts(self) -> List[Alert]:
        """Get all active (unresolved) alerts."""
        return [alert for alert in self.alerts if not alert.resolved]


class HealthChecker:
    """Performs health checks on system components."""

    def __init__(self):
        self.logger = get_logger("agent_etl.monitoring.health")
        self.health_checks: Dict[str, Callable] = {}
        self.health_status: Dict[str, HealthStatus] = {}

    def register_health_check(self, component: str, check_function: Callable) -> None:
        """Register a health check function for a component."""
        self.health_checks[component] = check_function
        self.logger.info(f"Registered health check for {component}")

    async def run_health_checks(self) -> Dict[str, HealthStatus]:
        """Run all registered health checks."""
        for component, check_function in self.health_checks.items():
            try:
                if asyncio.iscoroutinefunction(check_function):
                    result = await check_function()
                else:
                    result = check_function()

                if isinstance(result, dict):
                    healthy = result.get("healthy", True)
                    metrics = result.get("metrics", {})
                    error_message = result.get("error")
                else:
                    healthy = bool(result)
                    metrics = {}
                    error_message = None

                self.health_status[component] = HealthStatus(
                    component=component,
                    healthy=healthy,
                    metrics=metrics,
                    error_message=error_message
                )

            except Exception as e:
                self.logger.error(f"Health check failed for {component}: {e}")
                self.health_status[component] = HealthStatus(
                    component=component,
                    healthy=False,
                    error_message=str(e)
                )

        return self.health_status.copy()

    def get_overall_health(self) -> bool:
        """Get overall system health status."""
        if not self.health_status:
            return True  # No health checks registered

        return all(status.healthy for status in self.health_status.values())


class PerformanceProfiler:
    """Profiles performance of operations and identifies bottlenecks."""

    def __init__(self):
        self.logger = get_logger("agent_etl.monitoring.profiler")
        self.operation_times: Dict[str, List[float]] = {}
        self.active_operations: Dict[str, float] = {}

    def start_operation(self, operation_name: str) -> str:
        """Start timing an operation."""
        operation_id = f"{operation_name}_{int(time.time() * 1000000)}"
        self.active_operations[operation_id] = time.time()
        return operation_id

    def end_operation(self, operation_id: str) -> float:
        """End timing an operation and return duration."""
        if operation_id not in self.active_operations:
            self.logger.warning(f"Operation {operation_id} not found in active operations")
            return 0.0

        start_time = self.active_operations.pop(operation_id)
        duration = time.time() - start_time

        # Extract operation name from ID
        operation_name = "_".join(operation_id.split("_")[:-1])

        if operation_name not in self.operation_times:
            self.operation_times[operation_name] = []

        self.operation_times[operation_name].append(duration)

        # Keep only recent times (last 100 operations)
        if len(self.operation_times[operation_name]) > 100:
            self.operation_times[operation_name] = self.operation_times[operation_name][-100:]

        return duration

    def get_performance_stats(self) -> Dict[str, Dict[str, float]]:
        """Get performance statistics for all operations."""
        stats = {}

        for operation, times in self.operation_times.items():
            if times:
                stats[operation] = {
                    "count": len(times),
                    "avg_time": sum(times) / len(times),
                    "min_time": min(times),
                    "max_time": max(times),
                    "total_time": sum(times)
                }

                # Calculate percentiles
                sorted_times = sorted(times)
                stats[operation]["p50"] = sorted_times[len(sorted_times) // 2]
                stats[operation]["p90"] = sorted_times[int(len(sorted_times) * 0.9)]
                stats[operation]["p95"] = sorted_times[int(len(sorted_times) * 0.95)]

        return stats


class ComprehensiveMonitor:
    """Main monitoring system that coordinates all monitoring components."""

    def __init__(self):
        self.logger = get_logger("agent_etl.monitoring.main")
        self.metrics_collector = MetricsCollector()
        self.alert_manager = AlertManager()
        self.health_checker = HealthChecker()
        self.profiler = PerformanceProfiler()
        self.monitoring_active = False
        self.monitoring_task: Optional[asyncio.Task] = None

    def start_monitoring(self, interval: int = 30) -> None:
        """Start the monitoring system."""
        if self.monitoring_active:
            self.logger.warning("Monitoring is already active")
            return

        self.monitoring_active = True
        self.monitoring_task = asyncio.create_task(self._monitoring_loop(interval))
        self.logger.info("Monitoring system started")

    def stop_monitoring(self) -> None:
        """Stop the monitoring system."""
        self.monitoring_active = False
        if self.monitoring_task:
            self.monitoring_task.cancel()
        self.logger.info("Monitoring system stopped")

    async def _monitoring_loop(self, interval: int) -> None:
        """Main monitoring loop."""
        while self.monitoring_active:
            try:
                # Run health checks
                await self.health_checker.run_health_checks()

                # Get current metrics
                metrics = self.metrics_collector.get_aggregated_metrics()

                # Add health status to metrics
                for component, status in self.health_checker.health_status.items():
                    metrics[f"health_{component}"] = {
                        "name": f"health_{component}",
                        "last_value": 1.0 if status.healthy else 0.0,
                        "last_updated": status.last_check
                    }

                # Check alerts
                new_alerts = self.alert_manager.check_alerts(metrics)

                if new_alerts:
                    self.logger.info(f"Generated {len(new_alerts)} new alerts")

                # Log performance stats
                perf_stats = self.profiler.get_performance_stats()
                for operation, stats in perf_stats.items():
                    self.metrics_collector.set_gauge("operation_avg_time", stats["avg_time"], {"operation": operation})
                    self.metrics_collector.set_gauge("operation_count", stats["count"], {"operation": operation})

                await asyncio.sleep(interval)

            except Exception as e:
                self.logger.error(f"Error in monitoring loop: {e}")
                await asyncio.sleep(interval)

    def get_system_status(self) -> Dict[str, Any]:
        """Get comprehensive system status."""
        return {
            "health": {
                "overall_healthy": self.health_checker.get_overall_health(),
                "components": {name: status.healthy for name, status in self.health_checker.health_status.items()}
            },
            "metrics": self.metrics_collector.get_aggregated_metrics(),
            "alerts": {
                "active_count": len(self.alert_manager.get_active_alerts()),
                "active_alerts": [
                    {"name": alert.name, "severity": alert.severity.value, "message": alert.message}
                    for alert in self.alert_manager.get_active_alerts()
                ]
            },
            "performance": self.profiler.get_performance_stats()
        }

    # Convenience methods for common operations
    def record_metric(self, name: str, value: Union[int, float], **kwargs) -> None:
        """Record a metric."""
        self.metrics_collector.record_metric(name, value, **kwargs)

    def increment_counter(self, name: str, **kwargs) -> None:
        """Increment a counter."""
        self.metrics_collector.increment_counter(name, **kwargs)

    def set_gauge(self, name: str, value: Union[int, float], **kwargs) -> None:
        """Set a gauge value."""
        self.metrics_collector.set_gauge(name, value, **kwargs)

    def time_operation(self, operation_name: str):
        """Context manager for timing operations."""
        return TimedOperation(self.profiler, operation_name)


class TimedOperation:
    """Context manager for timing operations."""

    def __init__(self, profiler: PerformanceProfiler, operation_name: str):
        self.profiler = profiler
        self.operation_name = operation_name
        self.operation_id: Optional[str] = None

    def __enter__(self):
        self.operation_id = self.profiler.start_operation(self.operation_name)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.operation_id:
            duration = self.profiler.end_operation(self.operation_id)
            if exc_type is None:
                get_logger("agent_etl.monitoring.timer").info(
                    f"Operation {self.operation_name} completed in {duration:.3f}s"
                )


# Export main classes
__all__ = [
    "ComprehensiveMonitor",
    "MetricsCollector",
    "AlertManager",
    "HealthChecker",
    "PerformanceProfiler",
    "TimedOperation",
    "MetricType",
    "AlertSeverity",
    "Metric",
    "Alert",
    "HealthStatus"
]
