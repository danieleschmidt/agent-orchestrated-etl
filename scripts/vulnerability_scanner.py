#!/usr/bin/env python3
"""
Advanced Vulnerability Scanner for Agent-Orchestrated-ETL

Comprehensive security scanning that combines multiple tools and sources:
- Python package vulnerabilities (Safety, OSV)
- Container image vulnerabilities (Trivy)
- Code vulnerabilities (Bandit, Semgrep)
- License compliance checks
- Supply chain security analysis
"""

import asyncio
import json
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
import aiohttp
import hashlib


class VulnerabilityScanner:
    """Advanced vulnerability scanner with multiple detection methods."""
    
    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.output_dir = project_root / "security-reports"
        self.output_dir.mkdir(exist_ok=True)
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
    async def scan_python_packages(self) -> Dict[str, Any]:
        """Scan Python packages for vulnerabilities using multiple sources."""
        print("üîç Scanning Python packages...")
        
        results = {
            "source": "python-packages",
            "timestamp": datetime.utcnow().isoformat(),
            "vulnerabilities": [],
            "summary": {"total": 0, "critical": 0, "high": 0, "medium": 0, "low": 0}
        }
        
        # Safety scan
        try:
            safety_result = subprocess.run(
                [sys.executable, "-m", "safety", "check", "--json", "--full-report"],
                capture_output=True,
                text=True,
                cwd=self.project_root
            )
            
            if safety_result.stdout:
                safety_data = json.loads(safety_result.stdout)
                for vuln in safety_data:
                    vuln_info = {
                        "package": vuln.get("package"),
                        "version": vuln.get("installed_version"),
                        "vulnerability_id": vuln.get("id"),
                        "cve_id": vuln.get("cve"),
                        "title": vuln.get("advisory"),
                        "severity": self._map_safety_severity(vuln),
                        "source": "safety",
                        "fix_available": bool(vuln.get("fix_versions")),
                        "fix_versions": vuln.get("fix_versions", [])
                    }
                    results["vulnerabilities"].append(vuln_info)
                    results["summary"]["total"] += 1
                    results["summary"][vuln_info["severity"]] += 1
                    
        except Exception as e:
            print(f"‚ö†Ô∏è  Safety scan failed: {e}")
        
        # OSV API scan for additional coverage
        await self._osv_scan(results)
        
        return results
    
    async def _osv_scan(self, results: Dict[str, Any]) -> None:
        """Query OSV database for additional vulnerability data."""
        try:
            # Get installed packages
            pip_result = subprocess.run(
                [sys.executable, "-m", "pip", "list", "--format=json"],
                capture_output=True,
                text=True
            )
            
            if pip_result.returncode == 0:
                packages = json.loads(pip_result.stdout)
                
                async with aiohttp.ClientSession() as session:
                    for package in packages[:10]:  # Limit to avoid rate limiting
                        await self._query_osv_package(session, package, results)
                        
        except Exception as e:
            print(f"‚ö†Ô∏è  OSV scan failed: {e}")
    
    async def _query_osv_package(self, session: aiohttp.ClientSession, 
                                package: Dict[str, str], results: Dict[str, Any]) -> None:
        """Query OSV API for specific package."""
        try:
            query = {
                "version": package["version"],
                "package": {
                    "name": package["name"],
                    "ecosystem": "PyPI"
                }
            }
            
            async with session.post(
                "https://api.osv.dev/v1/query",
                json=query,
                timeout=aiohttp.ClientTimeout(total=10)
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    vulns = data.get("vulns", [])
                    
                    for vuln in vulns:
                        vuln_info = {
                            "package": package["name"],
                            "version": package["version"],
                            "vulnerability_id": vuln.get("id"),
                            "title": vuln.get("summary", ""),
                            "severity": self._map_osv_severity(vuln),
                            "source": "osv",
                            "published": vuln.get("published"),
                            "modified": vuln.get("modified"),
                            "references": [ref.get("url") for ref in vuln.get("references", [])]
                        }
                        
                        # Avoid duplicates
                        if not any(v["vulnerability_id"] == vuln_info["vulnerability_id"] 
                                 for v in results["vulnerabilities"]):
                            results["vulnerabilities"].append(vuln_info)
                            results["summary"]["total"] += 1
                            results["summary"][vuln_info["severity"]] += 1
                            
        except Exception as e:
            print(f"‚ö†Ô∏è  OSV query failed for {package['name']}: {e}")
    
    def scan_container_images(self) -> Dict[str, Any]:
        """Scan container images for vulnerabilities using Trivy."""
        print("üê≥ Scanning container images...")
        
        results = {
            "source": "container-images",
            "timestamp": datetime.utcnow().isoformat(),
            "images": [],
            "summary": {"total_images": 0, "total_vulnerabilities": 0}
        }
        
        # Check if Trivy is available
        try:
            subprocess.run(["trivy", "--version"], check=True, capture_output=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            results["error"] = "Trivy not available - install with: curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh"
            return results
        
        # Scan Dockerfile
        dockerfile_path = self.project_root / "Dockerfile"
        if dockerfile_path.exists():
            try:
                trivy_result = subprocess.run(
                    ["trivy", "fs", "--format", "json", str(dockerfile_path)],
                    capture_output=True,
                    text=True,
                    cwd=self.project_root
                )
                
                if trivy_result.returncode == 0 and trivy_result.stdout:
                    trivy_data = json.loads(trivy_result.stdout)
                    
                    for result in trivy_data.get("Results", []):
                        image_info = {
                            "target": result.get("Target"),
                            "type": result.get("Type"),
                            "vulnerabilities": []
                        }
                        
                        for vuln in result.get("Vulnerabilities", []):
                            vuln_info = {
                                "vulnerability_id": vuln.get("VulnerabilityID"),
                                "package_name": vuln.get("PkgName"),
                                "installed_version": vuln.get("InstalledVersion"),
                                "fixed_version": vuln.get("FixedVersion"),
                                "severity": vuln.get("Severity", "UNKNOWN").lower(),
                                "title": vuln.get("Title"),
                                "description": vuln.get("Description"),
                                "references": vuln.get("References", [])
                            }
                            image_info["vulnerabilities"].append(vuln_info)
                            results["summary"]["total_vulnerabilities"] += 1
                        
                        results["images"].append(image_info)
                        results["summary"]["total_images"] += 1
                        
            except Exception as e:
                print(f"‚ö†Ô∏è  Container scan failed: {e}")
        
        return results
    
    def scan_code_security(self) -> Dict[str, Any]:
        """Scan source code for security issues using Bandit and Semgrep."""
        print("üîí Scanning source code...")
        
        results = {
            "source": "code-security",
            "timestamp": datetime.utcnow().isoformat(),
            "bandit_results": {},
            "semgrep_results": {},
            "summary": {"total_issues": 0, "high": 0, "medium": 0, "low": 0}
        }
        
        # Bandit scan
        try:
            bandit_result = subprocess.run(
                ["bandit", "-r", "src/", "-f", "json"],
                capture_output=True,
                text=True,
                cwd=self.project_root
            )
            
            if bandit_result.stdout:
                bandit_data = json.loads(bandit_result.stdout)
                results["bandit_results"] = bandit_data
                
                # Process results
                for result in bandit_data.get("results", []):
                    severity = result.get("issue_severity", "low").lower()
                    results["summary"]["total_issues"] += 1
                    results["summary"][severity] += 1
                    
        except Exception as e:
            print(f"‚ö†Ô∏è  Bandit scan failed: {e}")
        
        # Semgrep scan (if available)
        try:
            subprocess.run(["semgrep", "--version"], check=True, capture_output=True)
            
            semgrep_result = subprocess.run(
                ["semgrep", "--config=auto", "--json", "src/"],
                capture_output=True,
                text=True,
                cwd=self.project_root
            )
            
            if semgrep_result.stdout:
                semgrep_data = json.loads(semgrep_result.stdout)
                results["semgrep_results"] = semgrep_data
                
        except (subprocess.CalledProcessError, FileNotFoundError):
            results["semgrep_results"] = {"error": "Semgrep not available"}
        except Exception as e:
            print(f"‚ö†Ô∏è  Semgrep scan failed: {e}")
        
        return results
    
    def check_license_compliance(self) -> Dict[str, Any]:
        """Check license compliance for all dependencies."""
        print("üìú Checking license compliance...")
        
        results = {
            "source": "license-compliance",
            "timestamp": datetime.utcnow().isoformat(),
            "packages": [],
            "compliance_issues": [],
            "allowed_licenses": ["MIT", "Apache-2.0", "BSD-3-Clause", "BSD-2-Clause", "ISC"],
            "summary": {"total_packages": 0, "compliant": 0, "non_compliant": 0, "unknown": 0}
        }
        
        try:
            # Use pip-licenses if available
            try:
                subprocess.run(["pip-licenses", "--version"], check=True, capture_output=True)
                
                license_result = subprocess.run(
                    ["pip-licenses", "--format=json"],
                    capture_output=True,
                    text=True
                )
                
                if license_result.returncode == 0:
                    license_data = json.loads(license_result.stdout)
                    
                    for package in license_data:
                        package_name = package.get("Name")
                        license_name = package.get("License")
                        
                        compliance_status = "compliant"
                        if license_name in results["allowed_licenses"]:
                            compliance_status = "compliant"
                            results["summary"]["compliant"] += 1
                        elif license_name in ["UNKNOWN", "UNSPECIFIED"]:
                            compliance_status = "unknown"
                            results["summary"]["unknown"] += 1
                        else:
                            compliance_status = "non_compliant"
                            results["summary"]["non_compliant"] += 1
                            results["compliance_issues"].append({
                                "package": package_name,
                                "license": license_name,
                                "issue": "License not in allowed list"
                            })
                        
                        results["packages"].append({
                            "name": package_name,
                            "version": package.get("Version"),
                            "license": license_name,
                            "compliance": compliance_status
                        })
                        
                        results["summary"]["total_packages"] += 1
                        
            except FileNotFoundError:
                results["error"] = "pip-licenses not available - install with: pip install pip-licenses"
                
        except Exception as e:
            print(f"‚ö†Ô∏è  License check failed: {e}")
        
        return results
    
    def _map_safety_severity(self, vuln: Dict[str, Any]) -> str:
        """Map Safety vulnerability to severity level."""
        # Safety doesn't provide severity, so we make educated guesses
        advisory = vuln.get("advisory", "").lower()
        if any(term in advisory for term in ["critical", "rce", "remote code", "arbitrary code"]):
            return "critical"
        elif any(term in advisory for term in ["high", "sql injection", "xss", "csrf"]):
            return "high"
        elif any(term in advisory for term in ["medium", "dos", "denial of service"]):
            return "medium"
        else:
            return "low"
    
    def _map_osv_severity(self, vuln: Dict[str, Any]) -> str:
        """Map OSV vulnerability to severity level."""
        # Check for CVSS score or severity indicators
        database_specific = vuln.get("database_specific", {})
        if "severity" in database_specific:
            return database_specific["severity"].lower()
        
        # Default mapping based on CVE patterns
        vuln_id = vuln.get("id", "")
        if "CVE" in vuln_id:
            return "medium"  # Default for CVEs
        else:
            return "low"
    
    async def generate_comprehensive_report(self) -> Dict[str, Any]:
        """Generate comprehensive security report combining all scans."""
        print("üìä Generating comprehensive security report...")
        
        # Run all scans
        python_results = await self.scan_python_packages()
        container_results = self.scan_container_images()
        code_results = self.scan_code_security()
        license_results = self.check_license_compliance()
        
        # Combine results
        comprehensive_report = {
            "project": "agent-orchestrated-etl",
            "scan_timestamp": datetime.utcnow().isoformat(),
            "scan_id": hashlib.md5(f"scan-{self.timestamp}".encode()).hexdigest()[:8],
            "scans": {
                "python_packages": python_results,
                "container_images": container_results,
                "code_security": code_results,
                "license_compliance": license_results
            },
            "overall_summary": {
                "total_vulnerabilities": (
                    python_results["summary"]["total"] +
                    container_results["summary"]["total_vulnerabilities"] +
                    code_results["summary"]["total_issues"]
                ),
                "critical_issues": (
                    python_results["summary"]["critical"] +
                    code_results["summary"]["high"]  # Map code high to critical
                ),
                "compliance_issues": len(license_results.get("compliance_issues", [])),
                "scan_coverage": {
                    "python_packages": "completed",
                    "containers": "completed" if "error" not in container_results else "failed",
                    "code_security": "completed",
                    "licenses": "completed" if "error" not in license_results else "partial"
                }
            },
            "recommendations": self._generate_recommendations(
                python_results, container_results, code_results, license_results
            )
        }
        
        return comprehensive_report
    
    def _generate_recommendations(self, python_results: Dict[str, Any], 
                                container_results: Dict[str, Any],
                                code_results: Dict[str, Any],
                                license_results: Dict[str, Any]) -> List[str]:
        """Generate actionable security recommendations."""
        recommendations = []
        
        # Python package recommendations
        if python_results["summary"]["total"] > 0:
            recommendations.append(
                f"Update {python_results['summary']['total']} vulnerable Python packages"
            )
            
            critical_vulns = [v for v in python_results["vulnerabilities"] 
                            if v["severity"] == "critical"]
            if critical_vulns:
                recommendations.append(
                    f"URGENT: Address {len(critical_vulns)} critical vulnerabilities immediately"
                )
        
        # Container recommendations
        if container_results["summary"]["total_vulnerabilities"] > 0:
            recommendations.append(
                "Update base images and system packages in containers"
            )
        
        # Code security recommendations
        if code_results["summary"]["total_issues"] > 0:
            recommendations.append(
                f"Fix {code_results['summary']['total_issues']} code security issues"
            )
        
        # License compliance recommendations
        if license_results.get("compliance_issues"):
            recommendations.append(
                f"Review {len(license_results['compliance_issues'])} license compliance issues"
            )
        
        # General recommendations
        recommendations.extend([
            "Enable automated dependency updates with Dependabot",
            "Implement security scanning in CI/CD pipeline",
            "Regular security training for development team",
            "Consider implementing SLSA compliance framework"
        ])
        
        return recommendations
    
    async def run_full_scan(self) -> None:
        """Run comprehensive security scan and save results."""
        print("üöÄ Starting comprehensive security scan...")
        
        report = await self.generate_comprehensive_report()
        
        # Save detailed report
        report_path = self.output_dir / f"security-report-{self.timestamp}.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)
        
        # Save summary report
        summary = {
            "scan_id": report["scan_id"],
            "timestamp": report["scan_timestamp"],
            "summary": report["overall_summary"],
            "top_recommendations": report["recommendations"][:5]
        }
        
        summary_path = self.output_dir / f"security-summary-{self.timestamp}.json"
        with open(summary_path, 'w') as f:
            json.dump(summary, f, indent=2)
        
        # Print summary
        print("\n" + "="*60)
        print("üîí SECURITY SCAN SUMMARY")
        print("="*60)
        print(f"Total vulnerabilities found: {report['overall_summary']['total_vulnerabilities']}")
        print(f"Critical issues: {report['overall_summary']['critical_issues']}")
        print(f"License compliance issues: {report['overall_summary']['compliance_issues']}")
        print(f"\nDetailed report: {report_path}")
        print(f"Summary report: {summary_path}")
        
        if report["overall_summary"]["critical_issues"] > 0:
            print("\n‚ö†Ô∏è  CRITICAL ISSUES FOUND - Immediate action required!")
            sys.exit(1)
        elif report["overall_summary"]["total_vulnerabilities"] > 0:
            print("\n‚ö†Ô∏è  Vulnerabilities found - Review and address soon.")
            sys.exit(0)
        else:
            print("\n‚úÖ No critical security issues found.")
            sys.exit(0)


async def main():
    """Main entry point."""
    project_root = Path(__file__).parent.parent
    scanner = VulnerabilityScanner(project_root)
    await scanner.run_full_scan()


if __name__ == "__main__":
    asyncio.run(main())